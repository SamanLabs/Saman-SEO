---
phase: 01-schema-engine-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - includes/Schema/class-schema-registry.php
  - includes/Schema/class-schema-graph-manager.php
autonomous: true

must_haves:
  truths:
    - "Schema_Registry can register new schema types via register() method"
    - "Schema_Registry can retrieve all registered types via get_types()"
    - "Schema_Registry can instantiate schemas via make() method"
    - "Schema_Graph_Manager combines schemas into single @graph array"
    - "Graph output has @context only at root level"
  artifacts:
    - path: "includes/Schema/class-schema-registry.php"
      provides: "Central registry for schema type registration"
      contains: "class Schema_Registry"
    - path: "includes/Schema/class-schema-graph-manager.php"
      provides: "Orchestrates schema collection and graph output"
      contains: "class Schema_Graph_Manager"
  key_links:
    - from: "includes/Schema/class-schema-registry.php"
      to: "includes/Schema/class-abstract-schema.php"
      via: "make() returns Abstract_Schema instances"
      pattern: "Abstract_Schema"
    - from: "includes/Schema/class-schema-graph-manager.php"
      to: "includes/Schema/class-schema-registry.php"
      via: "queries registry for types"
      pattern: "registry->get_types"
    - from: "includes/Schema/class-schema-graph-manager.php"
      to: "includes/Schema/class-schema-context.php"
      via: "passes context to schemas"
      pattern: "Schema_Context"
---

<objective>
Create the Schema Registry for type registration and the Graph Manager for combining schemas into JSON-LD output.

Purpose: The registry enables extensibility (third parties can register custom types) while the graph manager handles the orchestration of collecting applicable schemas and combining them into a properly structured @graph array.

Output: Two PHP classes that complete the schema engine core, ready for migration of existing schemas.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-schema-engine-foundation/01-RESEARCH.md
@.planning/phases/01-schema-engine-foundation/01-01-SUMMARY.md

Dependencies from Plan 01:
- Abstract_Schema class at includes/Schema/class-abstract-schema.php
- Schema_Context class at includes/Schema/class-schema-context.php
- Schema_IDs class at includes/Schema/class-schema-ids.php

Key patterns from research:
- Registry singleton with register(), get_types(), has(), make()
- Graph manager with build() that collects applicable schemas
- Backward compatibility filters: SAMAN_SEO_jsonld_graph
- New filter hooks: saman_seo_schema_{type}_output, saman_seo_schema_graph
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Schema_Registry singleton</name>
  <files>includes/Schema/class-schema-registry.php</files>
  <action>
Create the Schema_Registry class implementing the registration pattern.

Private properties:
- `static ?Schema_Registry $instance = null` - Singleton instance
- `array $types = []` - Registered types (slug => config array)

Public static method:
- `instance(): Schema_Registry` - Returns singleton, creates if null

Public methods:
- `register(string $slug, string $class_name, array $args = []): void`
  - Store in `$this->types[$slug]` with structure:
    ```php
    [
        'class'      => $class_name,
        'label'      => $args['label'] ?? ucfirst($slug),
        'post_types' => $args['post_types'] ?? [],
        'priority'   => $args['priority'] ?? 10,
    ]
    ```
  - Fire action: `do_action('saman_seo_schema_type_registered', $slug, $class_name, $args)`

- `get_types(): array`
  - Return `apply_filters('saman_seo_schema_types', $this->types)`

- `has(string $slug): bool`
  - Return `isset($this->types[$slug])`

- `make(string $slug, Schema_Context $context): ?Abstract_Schema`
  - Return null if `!$this->has($slug)`
  - Get class from `$this->types[$slug]['class']`
  - Return `new $class($context)`

- `get(string $slug): ?array`
  - Return `$this->types[$slug] ?? null`
  - Useful for getting type config (label, post_types, priority)

Private constructor to enforce singleton.

Use namespace `Saman\SEO\Schema`. Import Abstract_Schema, Schema_Context.
  </action>
  <verify>
Run `grep -E "public (static )?function" includes/Schema/class-schema-registry.php | wc -l` and verify at least 5 methods (instance, register, get_types, has, make, get).
  </verify>
  <done>Schema_Registry provides central type management with extensibility via filters and actions.</done>
</task>

<task type="auto">
  <name>Task 2: Create Schema_Graph_Manager orchestrator</name>
  <files>includes/Schema/class-schema-graph-manager.php</files>
  <action>
Create the Schema_Graph_Manager class that builds the complete JSON-LD graph.

Private properties:
- `Schema_Registry $registry` - Injected registry instance

Constructor:
- Accept `Schema_Registry $registry` parameter
- Store in `$this->registry`

Public method `build(Schema_Context $context): array`:
1. Initialize empty `$graph = []`

2. Get all registered types from registry (sorted by priority)
   ```php
   $types = $this->registry->get_types();
   uasort($types, fn($a, $b) => $a['priority'] <=> $b['priority']);
   ```

3. Loop through types:
   ```php
   foreach ($types as $slug => $config) {
       $schema = $this->registry->make($slug, $context);

       if ($schema && $schema->is_needed()) {
           $piece = $schema->generate();

           // Apply type-specific filter (new API)
           $piece = apply_filters("saman_seo_schema_{$slug}_output", $piece, $context);

           if (!empty($piece)) {
               $graph[] = $piece;
           }
       }
   }
   ```

4. Apply graph filters (new API + backward compatibility):
   ```php
   // New filter
   $graph = apply_filters('saman_seo_schema_graph', $graph, $context);

   // Legacy backward compatibility (CRITICAL per research)
   $graph = apply_filters('SAMAN_SEO_jsonld_graph', $graph, $context->post);
   ```

5. Return complete JSON-LD structure:
   ```php
   return [
       '@context' => 'https://schema.org',
       '@graph'   => $graph,
   ];
   ```

CRITICAL: @context is ONLY added here at root level, not in individual schema pieces. This is the single source of @context per research anti-patterns.

Use namespace `Saman\SEO\Schema`. Import Schema_Registry, Schema_Context.
  </action>
  <verify>
Run `grep -E "@context|@graph|SAMAN_SEO_jsonld_graph" includes/Schema/class-schema-graph-manager.php | wc -l` and verify at least 3 matches (context, graph, legacy filter).
  </verify>
  <done>Schema_Graph_Manager orchestrates schema collection with proper @graph structure and backward-compatible filters.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. File check: `ls includes/Schema/` shows 5 files total (3 from Plan 01 + 2 new)
2. Singleton: Schema_Registry has private constructor and instance() method
3. Extensibility: `grep "apply_filters" includes/Schema/*.php | wc -l` shows filter hooks
4. Backward compat: `grep "SAMAN_SEO_jsonld_graph" includes/Schema/class-schema-graph-manager.php` finds legacy filter
5. Root @context: Only Schema_Graph_Manager contains '@context' (not individual schemas)
</verification>

<success_criteria>
- [ ] Schema_Registry singleton with register(), get_types(), has(), make(), get() methods
- [ ] Schema_Registry fires saman_seo_schema_type_registered action on registration
- [ ] Schema_Registry applies saman_seo_schema_types filter in get_types()
- [ ] Schema_Graph_Manager constructor accepts Schema_Registry dependency
- [ ] Schema_Graph_Manager build() collects schemas where is_needed() returns true
- [ ] Schema_Graph_Manager applies saman_seo_schema_{type}_output filters per type
- [ ] Schema_Graph_Manager applies saman_seo_schema_graph filter on complete graph
- [ ] Schema_Graph_Manager applies legacy SAMAN_SEO_jsonld_graph filter for backward compatibility
- [ ] Only Schema_Graph_Manager adds @context (at root level)
- [ ] Types sorted by priority before processing
</success_criteria>

<output>
After completion, create `.planning/phases/01-schema-engine-foundation/01-02-SUMMARY.md`
</output>
