---
phase: 01-schema-engine-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - includes/Schema/class-abstract-schema.php
  - includes/Schema/class-schema-context.php
  - includes/Schema/class-schema-ids.php
autonomous: true

must_haves:
  truths:
    - "Abstract_Schema class exists with is_needed() and generate() methods"
    - "Schema_Context can be created from current WordPress state"
    - "Schema_IDs provides consistent URL#fragment identifiers"
  artifacts:
    - path: "includes/Schema/class-abstract-schema.php"
      provides: "Base schema class all types extend"
      contains: "abstract class Abstract_Schema"
    - path: "includes/Schema/class-schema-context.php"
      provides: "Environment context value object"
      contains: "class Schema_Context"
    - path: "includes/Schema/class-schema-ids.php"
      provides: "ID generation helpers"
      contains: "class Schema_IDs"
  key_links:
    - from: "includes/Schema/class-abstract-schema.php"
      to: "includes/Schema/class-schema-context.php"
      via: "constructor dependency injection"
      pattern: "Schema_Context \\$context"
    - from: "includes/Schema/class-abstract-schema.php"
      to: "includes/Schema/class-schema-ids.php"
      via: "get_id() method"
      pattern: "Schema_IDs::"
---

<objective>
Create the foundational schema infrastructure classes that all schema types will depend on.

Purpose: Establish the core building blocks (Abstract_Schema base class, Schema_Context value object, Schema_IDs helper) that enable the registry-based architecture. These classes provide the contract and utilities that every schema implementation will use.

Output: Three PHP classes in the new includes/Schema/ directory that follow Yoast-inspired patterns from RESEARCH.md.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-schema-engine-foundation/01-RESEARCH.md

Key patterns from research:
- Abstract_Schema: is_needed(), generate(), get_type() contract
- Schema_Context: Value object with canonical, site_url, site_name, post, post_type, meta, schema_type
- Schema_IDs: Static helper with website(), organization(), person(), webpage(), article(), breadcrumb(), author()
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Schema_IDs helper class</name>
  <files>includes/Schema/class-schema-ids.php</files>
  <action>
Create the Schema_IDs static helper class in new includes/Schema/ directory.

Implement these static methods (all return string):
- `website()` - returns `home_url('/') . '#website'`
- `organization()` - returns `home_url('/') . '#organization'`
- `person()` - returns `home_url('/') . '#person'`
- `webpage(string $url)` - returns `$url . '#webpage'`
- `article(string $url)` - returns `$url . '#article'`
- `breadcrumb(string $url)` - returns `$url . '#breadcrumb'`
- `author(int $user_id)` - returns `get_author_posts_url($user_id) . '#author'`

Use namespace `Saman\SEO\Schema`. Add ABSPATH check. Include PHPDoc for each method.

This class has no dependencies on other new classes - it only uses WordPress functions.
  </action>
  <verify>
File exists at includes/Schema/class-schema-ids.php and contains all 7 static methods. Run `grep -c "public static function" includes/Schema/class-schema-ids.php` and verify output is 7.
  </verify>
  <done>Schema_IDs class provides consistent @id fragment generation for all schema types.</done>
</task>

<task type="auto">
  <name>Task 2: Create Schema_Context value object</name>
  <files>includes/Schema/class-schema-context.php</files>
  <action>
Create the Schema_Context class that holds all environment data schemas need.

Public properties (all typed with PHPDoc):
- `string $canonical` - Canonical URL for current page
- `string $site_url` - Site home URL
- `string $site_name` - Site name from bloginfo
- `?WP_Post $post` - Current post object or null
- `string $post_type` - Post type slug or empty string
- `array $meta` - Post SEO meta from `_SAMAN_SEO_meta`
- `string $schema_type` - Determined schema type for post

Implement static factory method `from_current()`:
1. Create new instance
2. Set `site_url` = `home_url('/')`
3. Set `site_name` = `get_bloginfo('name')`
4. Set `post` = `get_post()` (may be null)
5. Set `post_type` = post type if post exists, else empty string
6. Set `canonical` = permalink if post exists, else site_url
7. Set `meta` = post meta `_SAMAN_SEO_meta` if post exists, cast to array
8. Determine `schema_type`:
   - Check `$meta['schema_type']` first
   - Fall back to `SAMAN_SEO_post_type_seo_settings` option for post type
   - Default to 'Article'

Also implement `from_post(WP_Post $post)` static factory for explicit post context.

Use namespace `Saman\SEO\Schema`. No @context should be in this class (that's only at root level per research anti-patterns).
  </action>
  <verify>
File exists with Schema_Context class. Run `grep "from_current\|from_post" includes/Schema/class-schema-context.php` and verify both factory methods exist.
  </verify>
  <done>Schema_Context provides immutable environment data to all schemas without global state access.</done>
</task>

<task type="auto">
  <name>Task 3: Create Abstract_Schema base class</name>
  <files>includes/Schema/class-abstract-schema.php</files>
  <action>
Create the Abstract_Schema class that all schema types extend.

Protected property:
- `Schema_Context $context` - injected via constructor

Constructor:
- Accept `Schema_Context $context` parameter
- Store in `$this->context`

Abstract methods (all schema types MUST implement):
- `public function is_needed(): bool` - Determine if schema should output
- `public function generate(): array` - Build the schema array (WITHOUT @context)
- `public function get_type()` - Return string or array of @type values

Protected helper method:
- `protected function get_id(): string` - Default implementation returns `$this->context->canonical . '#' . strtolower($this->get_type())` (handles string type, for array use first element)

CRITICAL: The generate() method must NOT include @context in its return. Per research, only the root JSON-LD object (in Graph_Manager) should have @context. This is a common pitfall identified in RESEARCH.md.

Use namespace `Saman\SEO\Schema`. Import Schema_Context at top.
  </action>
  <verify>
File exists with abstract class. Run `grep -E "abstract (class|function)" includes/Schema/class-abstract-schema.php` and verify: 1 abstract class, 3 abstract functions (is_needed, generate, get_type).
  </verify>
  <done>Abstract_Schema establishes the contract all schema implementations follow (Yoast pattern).</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Directory structure: `ls includes/Schema/` shows 3 files
2. Namespace check: `grep "namespace Saman\\SEO\\Schema" includes/Schema/*.php | wc -l` returns 3
3. Contract check: Abstract_Schema has is_needed(), generate(), get_type() as abstract
4. No @context in Abstract_Schema generate() PHPDoc/comments (emphasize this constraint)
</verification>

<success_criteria>
- [ ] includes/Schema/ directory created with 3 PHP files
- [ ] Schema_IDs has 7 static methods for ID generation
- [ ] Schema_Context has from_current() and from_post() factories
- [ ] Schema_Context determines schema_type from meta or post type settings
- [ ] Abstract_Schema declares is_needed(), generate(), get_type() as abstract
- [ ] Abstract_Schema constructor accepts Schema_Context dependency
- [ ] All classes use Saman\SEO\Schema namespace
- [ ] No @context in individual schema output (only at root)
</success_criteria>

<output>
After completion, create `.planning/phases/01-schema-engine-foundation/01-01-SUMMARY.md`
</output>
