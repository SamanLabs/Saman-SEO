---
phase: 07-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - includes/Integration/class-woocommerce.php
  - includes/Schema/Types/class-product-schema.php
  - includes/Schema/class-schema-ids.php
autonomous: true

must_haves:
  truths:
    - "WooCommerce native JSON-LD schema is disabled when plugin active"
    - "Product schema only outputs on singular product pages"
    - "Product schema type auto-registers when WooCommerce detected"
    - "Product_Schema class extends Abstract_Schema and integrates with registry"
  artifacts:
    - path: "includes/Integration/class-woocommerce.php"
      provides: "WC schema disable + Product schema registration"
      contains: "disable_wc_structured_data"
    - path: "includes/Schema/Types/class-product-schema.php"
      provides: "Product_Schema class extending Abstract_Schema"
      contains: "class Product_Schema extends Abstract_Schema"
    - path: "includes/Schema/class-schema-ids.php"
      provides: "product() static method for @id generation"
      contains: "public static function product"
  key_links:
    - from: "includes/Integration/class-woocommerce.php"
      to: "WC()->structured_data"
      via: "remove_action on init priority 0"
      pattern: "remove_action.*output_structured_data"
    - from: "includes/Integration/class-woocommerce.php"
      to: "Schema_Registry"
      via: "saman_seo_register_schema_type action"
      pattern: "saman_seo_register_schema_type.*register_product_schema"
    - from: "includes/Schema/Types/class-product-schema.php"
      to: "is_singular check"
      via: "is_needed() implementation"
      pattern: "is_singular.*product"
---

<objective>
Establish WooCommerce integration foundation with proper schema conflict prevention.

Purpose: Enable the plugin to output its own Product schema without conflicting with WooCommerce's native JSON-LD output. This is the critical foundation for all subsequent Product schema work.

Output: Refactored WooCommerce integration class that disables WC native schema and registers Product_Schema, plus a skeleton Product_Schema class ready for property implementation in Phase 8.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-foundation/07-RESEARCH.md

@includes/Schema/class-abstract-schema.php
@includes/Schema/class-schema-registry.php
@includes/Schema/class-schema-ids.php
@includes/Integration/class-woocommerce.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor WooCommerce integration to disable native schema and register Product type</name>
  <files>includes/Integration/class-woocommerce.php</files>
  <action>
Refactor the existing WooCommerce integration class:

1. **Remove** the existing `add_product_schema()` method and its filter hook on `SAMAN_SEO_jsonld_graph` - this old approach doesn't integrate with the registry.

2. **Remove** the private helper methods that are no longer needed: `build_product_schema()`, `get_product_brand()`, `build_offer_schema()`, `get_availability_url()`, `build_rating_schema()`, `build_reviews_schema()`. These will be rebuilt in the proper Product_Schema class in Phase 8.

3. **Keep** the `is_active()` static method and `get_meta_fields()` static method (still needed).

4. **Modify** the `boot()` method to:
   - Add hook: `add_action( 'init', [ $this, 'disable_wc_structured_data' ], 0 );`
   - Add hook: `add_action( 'saman_seo_register_schema_type', [ $this, 'register_product_schema' ] );`

5. **Add** new method `disable_wc_structured_data()`:
```php
public function disable_wc_structured_data(): void {
    if ( ! function_exists( 'WC' ) || null === WC()->structured_data ) {
        return;
    }
    remove_action( 'wp_footer', [ WC()->structured_data, 'output_structured_data' ], 10 );
    remove_action( 'woocommerce_email_order_details', [ WC()->structured_data, 'output_email_structured_data' ], 30 );
}
```

6. **Add** new method `register_product_schema()`:
```php
public function register_product_schema( \Saman\SEO\Schema\Schema_Registry $registry ): void {
    $registry->register(
        'product',
        \Saman\SEO\Schema\Types\Product_Schema::class,
        [
            'label'      => __( 'Product', 'saman-seo' ),
            'post_types' => [ 'product' ],
            'priority'   => 16,
        ]
    );
}
```

Follow the PHPDoc style from existing codebase for all new methods.
  </action>
  <verify>
1. `grep -n "disable_wc_structured_data\|register_product_schema" includes/Integration/class-woocommerce.php` shows both methods
2. `grep -n "SAMAN_SEO_jsonld_graph" includes/Integration/class-woocommerce.php` returns nothing (old hook removed)
3. `grep -n "build_product_schema\|build_offer_schema" includes/Integration/class-woocommerce.php` returns nothing (old methods removed)
  </verify>
  <done>
WooCommerce integration class refactored: disables WC native schema on init priority 0, registers Product schema type via saman_seo_register_schema_type action.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Product_Schema class skeleton</name>
  <files>includes/Schema/Types/class-product-schema.php</files>
  <action>
Create a new file `includes/Schema/Types/class-product-schema.php` with skeleton Product_Schema class:

```php
<?php
/**
 * Product Schema class.
 *
 * Generates Product schema for WooCommerce products.
 * Only outputs on singular product pages.
 *
 * @package Saman\SEO\Schema\Types
 * @since   1.1.0
 */

namespace Saman\SEO\Schema\Types;

use Saman\SEO\Schema\Abstract_Schema;
use Saman\SEO\Schema\Schema_IDs;

if ( ! defined( 'ABSPATH' ) ) {
    exit;
}

/**
 * Product schema implementation for WooCommerce products.
 *
 * Integrates with the schema engine to provide structured data
 * for Google Product rich results.
 */
class Product_Schema extends Abstract_Schema {

    /**
     * Get the schema @type value.
     *
     * @return string The schema type.
     */
    public function get_type(): string {
        return 'Product';
    }

    /**
     * Determine if Product schema should be output.
     *
     * Only outputs on singular product pages with valid WC_Product.
     *
     * @return bool True if on singular product page with valid product.
     */
    public function is_needed(): bool {
        // CRITICAL: Never output on archives/shop pages per Google guidelines
        if ( ! is_singular( 'product' ) ) {
            return false;
        }

        // Require valid WC_Product object
        $product = wc_get_product( $this->context->post );
        return $product instanceof \WC_Product;
    }

    /**
     * Generate the Product schema array.
     *
     * @return array Product schema data (without @context).
     */
    public function generate(): array {
        $product = wc_get_product( $this->context->post );

        // Validate required fields exist
        if ( ! $product || empty( $product->get_name() ) ) {
            return [];
        }

        $schema = [
            '@type' => $this->get_type(),
            '@id'   => $this->get_id(),
            'name'  => $product->get_name(),
            'url'   => $this->context->canonical,
        ];

        // Additional properties (description, image, sku, offers, etc.)
        // will be added in Phase 8: Simple Products

        return $this->apply_fields_filter( $schema );
    }

    /**
     * Get the Product schema @id.
     *
     * @return string URL#product identifier.
     */
    protected function get_id(): string {
        return Schema_IDs::product( $this->context->canonical );
    }
}
```

This skeleton:
- Extends Abstract_Schema correctly
- Implements all required abstract methods
- Has strict is_needed() check for is_singular('product')
- Uses Schema_IDs::product() for consistent @id
- Applies fields filter for developer extensibility
- Has proper namespace, PHPDoc, and coding standards
  </action>
  <verify>
1. File exists: `ls includes/Schema/Types/class-product-schema.php`
2. `grep -n "class Product_Schema extends Abstract_Schema" includes/Schema/Types/class-product-schema.php` shows inheritance
3. `grep -n "is_singular.*product" includes/Schema/Types/class-product-schema.php` shows the critical check
4. `grep -n "Schema_IDs::product" includes/Schema/Types/class-product-schema.php` shows @id usage
  </verify>
  <done>
Product_Schema class created with proper Abstract_Schema contract implementation, strict is_singular('product') check, and ready for property expansion in Phase 8.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add product() method to Schema_IDs</name>
  <files>includes/Schema/class-schema-ids.php</files>
  <action>
Add a new static method to the Schema_IDs class for Product schema @id generation:

After the `localbusiness()` method (around line 119), add:

```php
/**
 * Get the Product schema @id for a specific URL.
 *
 * @param string $url The canonical URL of the product.
 * @return string URL#product identifier.
 */
public static function product( string $url ): string {
    return $url . '#product';
}
```

This follows the same pattern as `article()`, `webpage()`, `faqpage()`, `howto()` methods that take a URL parameter.
  </action>
  <verify>
1. `grep -n "public static function product" includes/Schema/class-schema-ids.php` shows the new method
2. `grep -n "#product" includes/Schema/class-schema-ids.php` shows the fragment identifier
  </verify>
  <done>
Schema_IDs extended with product() static method returning URL#product identifier, consistent with other URL-based schema @id methods.
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify:

1. **WC schema disabled:** The WooCommerce integration hooks into init at priority 0 to remove WC structured data output
   - `grep "add_action.*init.*disable_wc_structured_data" includes/Integration/class-woocommerce.php`

2. **Product registered:** Product schema is registered via the proper action hook
   - `grep "saman_seo_register_schema_type.*register_product_schema" includes/Integration/class-woocommerce.php`

3. **is_singular check:** Product_Schema only outputs on singular product pages
   - `grep "is_singular.*product" includes/Schema/Types/class-product-schema.php`

4. **Schema_IDs extended:** product() method exists
   - `grep "public static function product" includes/Schema/class-schema-ids.php`

5. **Old code removed:** No traces of the old SAMAN_SEO_jsonld_graph approach
   - `grep "SAMAN_SEO_jsonld_graph\|build_product_schema" includes/Integration/class-woocommerce.php` returns nothing
</verification>

<success_criteria>
- [ ] WooCommerce integration class refactored with new boot() hooks
- [ ] disable_wc_structured_data() method removes WC native schema output
- [ ] register_product_schema() method registers Product type with priority 16
- [ ] Product_Schema class exists in includes/Schema/Types/
- [ ] Product_Schema extends Abstract_Schema correctly
- [ ] Product_Schema::is_needed() returns true only for is_singular('product')
- [ ] Product_Schema::generate() returns minimal schema with @type, @id, name, url
- [ ] Schema_IDs::product() method added for @id generation
- [ ] Old build_product_schema and related methods removed from WooCommerce class
- [ ] All PHP files pass syntax check (no parse errors)
</success_criteria>

<output>
After completion, create `.planning/phases/07-foundation/07-01-SUMMARY.md`
</output>
